# üß† Theory of Computation ‚Äì Mathematical Notations

## üî§ Basic Concepts

### Alphabet (Œ£)
**What it is:** A finite set of symbols/characters used to build strings.  
**Example:** `Œ£ = {0, 1}` or `Œ£ = {a, b, c}`

### String (w)
**What it is:** A finite sequence of symbols from an alphabet.  
**Example:** `"0110"`, `"abc"`, `"hello"`

### Empty String (Œµ or Œª)
**What it is:** A string with zero characters (length = 0).  
**Notation:** `Œµ` or `Œª`

### String Length (|w|)
**What it is:** The number of symbols in a string.  
**Example:** `|"abc"| = 3`, `|Œµ| = 0`

### Language (L)
**What it is:** A set of strings (can be finite or infinite).  
**Example:** `L = {w | w starts with '0'}` = `{0, 00, 01, 000, 001, ...}`

### Kleene Star (Œ£*)
**What it is:** All possible strings (including empty string) that can be formed from alphabet Œ£.  
**Example:** `{0,1}* = {Œµ, 0, 1, 00, 01, 10, 11, 000, ...}`

### Kleene Plus (Œ£‚Å∫)
**What it is:** All possible non-empty strings from alphabet Œ£ (excludes Œµ).  
**Example:** `{0,1}‚Å∫ = {0, 1, 00, 01, 10, 11, 000, ...}`

---

## ü§ñ Automata Models

### Finite Automaton (FA)
**What it is:** A simple machine with finite memory that reads input and accepts/rejects strings.  
**Types:** DFA, NFA

### Deterministic Finite Automaton (DFA)
**What it is:** A finite automaton where each state has exactly one transition for each input symbol.  
**Key Rule:** No choices ‚Äî deterministic behavior.  
**Format:** `M = (Q, Œ£, Œ¥, q‚ÇÄ, F)`

### Nondeterministic Finite Automaton (NFA)
**What it is:** A finite automaton where a state can have multiple transitions (or none) for the same input symbol.  
**Key Rule:** Can make choices ‚Äî explores multiple paths simultaneously.  
**Format:** `M = (Q, Œ£, Œ¥, q‚ÇÄ, F)` where `Œ¥: Q √ó (Œ£ ‚à™ {Œµ}) ‚Üí P(Q)`

### Œµ-NFA (Epsilon-NFA)
**What it is:** An NFA that allows transitions without reading any input symbol (Œµ-transitions).  
**Key Feature:** Can "jump" between states for free.

### Pushdown Automaton (PDA)
**What it is:** An automaton with a stack (infinite memory) that can recognize context-free languages.  
**Key Feature:** Can push/pop symbols from stack.  
**Format:** `M = (Q, Œ£, Œì, Œ¥, q‚ÇÄ, Z‚ÇÄ, F)`

### Turing Machine (TM)
**What it is:** The most powerful computational model ‚Äî an automaton with an infinite tape that can read, write, and move left/right.  
**Key Feature:** Can simulate any algorithm.  
**Format:** `M = (Q, Œ£, Œì, Œ¥, q‚ÇÄ, B, F)`

### Linear Bounded Automaton (LBA)
**What it is:** A Turing Machine restricted to use only the tape space occupied by the input.  
**Key Feature:** Limited tape = less power than TM.

---

## üèóÔ∏è Automata Components

### State (q)
**What it is:** A configuration/position in the automaton at any moment.  
**Example:** `q‚ÇÄ, q‚ÇÅ, q‚ÇÇ`

### Set of States (Q)
**What it is:** All possible states in the automaton.  
**Example:** `Q = {q‚ÇÄ, q‚ÇÅ, q‚ÇÇ, q‚ÇÉ}`

### Start State (q‚ÇÄ)
**What it is:** The initial state where computation begins.  
**Notation:** `q‚ÇÄ` or marked with an arrow `‚Üí`

### Final/Accepting State (F)
**What it is:** A state where the automaton accepts the input string.  
**Notation:** Double circle `‚äö` or `F ‚äÜ Q`

### Transition Function (Œ¥)
**What it is:** A rule that defines how the automaton moves from one state to another based on input.  
**DFA Example:** `Œ¥(q‚ÇÅ, a) = q‚ÇÇ`  
**NFA Example:** `Œ¥(q‚ÇÅ, a) = {q‚ÇÇ, q‚ÇÉ}`

### Dead State (Trap State)
**What it is:** A non-accepting state from which no escape is possible.  
**Purpose:** Captures all rejected strings.

---

## üìö Language Classes

### Regular Language (Type-3)
**What it is:** A language that can be recognized by a DFA/NFA or described by a regular expression.  
**Examples:** Languages with patterns like "strings ending in '01'", "even number of 0's"

### Context-Free Language (CFL) (Type-2)
**What it is:** A language that can be recognized by a PDA or generated by a context-free grammar.  
**Examples:** Balanced parentheses `{a‚Åøb‚Åø | n ‚â• 0}`, nested structures

### Context-Sensitive Language (CSL) (Type-1)
**What it is:** A language that can be recognized by a Linear Bounded Automaton.  
**Feature:** More complex than CFL but less than recursively enumerable.

### Recursively Enumerable Language (Type-0)
**What it is:** A language that can be recognized by a Turing Machine.  
**Feature:** Most general class ‚Äî may not halt on all inputs.

### Recursive Language
**What it is:** A language that can be decided by a Turing Machine (always halts).  
**Key Difference from RE:** Guaranteed to halt on all inputs.

---

## üìù Grammars

### Grammar (G)
**What it is:** A set of rules for generating strings in a language.  
**Format:** `G = (V, T, P, S)`

### Context-Free Grammar (CFG)
**What it is:** A grammar where each production rule has a single non-terminal on the left side.  
**Format:** `A ‚Üí Œ±` where `A` is non-terminal, `Œ±` is any string of terminals/non-terminals

### Regular Grammar
**What it is:** A restricted CFG where productions are in the form `A ‚Üí aB` or `A ‚Üí a`.  
**Types:** Left-linear, Right-linear

### Production Rule (P)
**What it is:** A rule that defines how to replace symbols in a grammar.  
**Example:** `S ‚Üí aSb | Œµ`

### Terminals (T)
**What it is:** Symbols that appear in the final strings (alphabet symbols).  
**Example:** `{a, b, 0, 1}`

### Non-Terminals (V)
**What it is:** Variables/symbols used to generate strings but don't appear in final output.  
**Example:** `{S, A, B}` (often uppercase letters)

### Start Symbol (S)
**What it is:** The initial non-terminal from which derivation begins.  
**Notation:** Usually `S`

---

## üéØ Regular Expressions

### Regular Expression (RegEx / RE)
**What it is:** A notation to describe patterns of strings in regular languages.  
**Example:** `(0|1)*` = all binary strings

### Union (|)
**What it is:** Matches either pattern.  
**Example:** `a|b` matches `"a"` or `"b"`

### Concatenation (¬∑)
**What it is:** Matches patterns in sequence.  
**Example:** `ab` matches `"ab"`

### Kleene Star (*)
**What it is:** Matches zero or more repetitions.  
**Example:** `a*` matches `"", "a", "aa", "aaa", ...`

### Kleene Plus (+)
**What it is:** Matches one or more repetitions.  
**Example:** `a‚Å∫` matches `"a", "aa", "aaa", ...` (not empty string)

---

## üîÑ Closure Properties

### Closure
**What it is:** If you perform an operation on languages of a certain class, the result stays in the same class.  
**Example:** Union of two regular languages is also regular.

### Pumping Lemma
**What it is:** A property used to prove a language is NOT regular or NOT context-free.  
**Idea:** In sufficiently long strings, there's a part you can "pump" (repeat) and stay in the language.

---

## üß© Decision Problems

### Decidable Problem
**What it is:** A problem for which a Turing Machine can always give a yes/no answer and halt.  
**Example:** "Is this number even?"

### Undecidable Problem
**What it is:** A problem for which no algorithm can solve it for all inputs.  
**Example:** The Halting Problem ‚Äî "Will this program halt on this input?"

### Halting Problem
**What it is:** The problem of determining whether a given program will eventually halt or run forever.  
**Status:** Proven undecidable by Alan Turing.

---

## üß† Complexity Concepts

### Deterministic Time (P)
**What it is:** Problems solvable by a deterministic Turing Machine in polynomial time.  
**Informal:** "Easy" problems

### Nondeterministic Polynomial Time (NP)
**What it is:** Problems where a solution can be verified in polynomial time.  
**Informal:** "Easy to check" problems

### NP-Complete
**What it is:** The hardest problems in NP ‚Äî if you solve one, you solve them all.  
**Examples:** SAT, Traveling Salesman Problem (decision version)

### NP-Hard
**What it is:** Problems at least as hard as NP-complete problems (may not be in NP).  
**Feature:** No known polynomial-time solution.

---

## üîß Special Concepts

### Transition Diagram (State Diagram)
**What it is:** A visual representation of an automaton using circles (states) and arrows (transitions).  
**Purpose:** Easy to understand automaton behavior.

### Acceptance
**What it is:** An automaton accepts a string if, after reading it completely, it ends in a final state.

### Rejection
**What it is:** An automaton rejects a string if it doesn't end in a final state or gets stuck.

### Configuration (Instantaneous Description)
**What it is:** A snapshot of the automaton's current state, remaining input, and stack/tape contents.  
**PDA Example:** `(q‚ÇÅ, w, Œ±)` ‚Äî state, remaining input, stack

### Derivation
**What it is:** A sequence of steps showing how a string is generated from a grammar's start symbol.  
**Types:** Leftmost, Rightmost

### Parse Tree
**What it is:** A tree representation showing how a string is derived from a grammar.  
**Nodes:** Root = start symbol, leaves = terminals

### Ambiguity
**What it is:** A grammar is ambiguous if a string has more than one parse tree.  
**Problem:** Multiple meanings for the same string.

---

## üìä Quick Comparison Table

| Model | Memory | Power | Language Class |
|-------|--------|-------|----------------|
| **DFA** | None (finite states) | Weakest | Regular |
| **NFA** | None (finite states) | Weakest | Regular |
| **PDA** | Stack (infinite) | Medium | Context-Free |
| **LBA** | Limited tape | Strong | Context-Sensitive |
| **TM** | Infinite tape | Strongest | Recursively Enumerable |

---

## üéì Memory Aid

**Think of it like this:**
- **Alphabet** = Your ingredients
- **String** = A dish made from ingredients
- **Language** = A menu of dishes
- **DFA** = A vending machine (fixed choices)
- **NFA** = A choose-your-own-adventure book (multiple paths)
- **PDA** = A stack of plates (can remember sequence)
- **TM** = A full computer (unlimited power)

## üéì Greek Symbols

### Most Common in TOC

| Symbol | Name | Usage in TOC |
|--------|------|--------------|
| **`Œ£`** | **Sigma** | **Input alphabet (set of symbols)** |
| `œÉ` | sigma | A single symbol from alphabet |
| **`Œµ`** | **epsilon** | **Empty string (length 0)** |
| **`Œª`** | **lambda** | **Empty string (alternative) / Lambda calculus** |
| **`Œ¥`** | **delta** | **Transition function** |
| `Œî` | Delta | Set of transitions |
| `Œì` | Gamma | Stack alphabet (in PDA) |
| `Œ≥` | gamma | Stack symbol |
| `œâ` | omega | String or word |
| `Œ©` | Omega | Asymptotic lower bound |
| `Œò` | Theta | Asymptotic tight bound |
| `Œ±` | alpha | Generic variable/symbol |
| `Œ≤` | beta | Generic variable/symbol |
| `œÄ` | pi | Projection, permutation |
| `œÅ` | rho | String, relation |
| `œÑ` | tau | Time, transition |
| `œÜ` / `œï` | phi | Function, empty set (alternative) |
| `œà` | psi | Function, predicate |
| `Œº` | mu | Minimal element |
| `ŒΩ` | nu | Index variable |

### Complete Greek Alphabet

#### Lowercase Letters

| Symbol | Name | Usage in TOC |
|--------|------|--------------|
| `Œ±` | alpha | Variables, strings |
| `Œ≤` | beta | Variables, strings |
| `Œ≥` | gamma | Stack symbols |
| `Œ¥` | delta | Transition function |
| `Œµ` | epsilon | Empty string |
| `Œ∂` | zeta | Rarely used |
| `Œ∑` | eta | Efficiency |
| `Œ∏` | theta | Angles, tight bound |
| `Œπ` | iota | Index |
| `Œ∫` | kappa | Rarely used |
| `Œª` | lambda | Empty string, lambda calculus |
| `Œº` | mu | Minimal |
| `ŒΩ` | nu | Index |
| `Œæ` | xi | Random variable |
| `Œø` | omicron | Rarely used |
| `œÄ` | pi | Product, projection |
| `œÅ` | rho | Strings |
| `œÉ` / `œÇ` | sigma | Symbol from alphabet |
| `œÑ` | tau | Time |
| `œÖ` | upsilon | Rarely used |
| `œÜ` / `œï` | phi | Functions |
| `œá` | chi | Rarely used |
| `œà` | psi | Functions |
| `œâ` | omega | Strings, words |

#### Uppercase Letters

| Symbol | Name | Usage in TOC |
|--------|------|--------------|
| `Œì` | Gamma | Stack alphabet |
| `Œî` | Delta | Transition set, change |
| `Œò` | Theta | Tight complexity bound |
| `Œõ` | Lambda | Set of strings |
| `Œ†` | Pi | Product, projection |
| `Œ£` | Sigma | Input alphabet |
| `Œ¶` | Phi | Functions, sets |
| `Œ®` | Psi | Functions |
| `Œ©` | Omega | Lower complexity bound |

### How to Read Common Expressions

#### Automata Definition
```
M = (Q, Œ£, Œ¥, q‚ÇÄ, F)
```
**Read as:** "M equals Q, Sigma, delta, q-zero, F"

#### Transition Function
```
Œ¥: Q √ó Œ£ ‚Üí Q
```
**Read as:** "delta from Q cross Sigma to Q"

#### Language
```
L = {œâ | œâ ‚àà Œ£*}
```
**Read as:** "L equals all omega such that omega belongs to Sigma star"

---

## ‚öôÔ∏è 1. SETS

**Definition:** A set is a collection of distinct objects or elements.

**Example:** `A = {1, 2, 3, 4}`

### Set Membership & Relations

| Symbol | Meaning | Example | Explanation |
|--------|---------|---------|-------------|
| `‚àà` | belongs to | `2 ‚àà A` | 2 is an element of A |
| `‚àâ` | does not belong to | `5 ‚àâ A` | 5 is not in A |
| `‚äÜ` | subset | `{1,2} ‚äÜ A` | all elements are in A |
| `‚äÇ` | proper subset | `{1,2} ‚äÇ A` | subset but not equal to A |
| `‚äá` | superset | `A ‚äá {1,2}` | A contains all these elements |
| `|A|` | cardinality | `|A| = 4` | number of elements in A |

---

## üí° 2. SET OPERATIONS

| Operation | Symbol | Example | Result | Meaning |
|-----------|--------|---------|--------|---------|
| **Union** | `‚à™` | `{1,2} ‚à™ {2,3}` | `{1,2,3}` | Combine both sets |
| **Intersection** | `‚à©` | `{1,2} ‚à© {2,3}` | `{2}` | Common elements only |
| **Difference** | `‚àí` | `{1,2,3} ‚àí {2}` | `{1,3}` | Elements only in first set |
| **Complement** | `A‚Ä≤` or `ƒÄ` | `U={1,2,3,4}, A={1,2}` | `A‚Ä≤={3,4}` | Elements not in A |

### Important Set Rules

```
‚úì A ‚à™ ‚àÖ = A                  (union with empty set)
‚úì A ‚à© ‚àÖ = ‚àÖ                  (intersection with empty set)
‚úì A ‚à™ A‚Ä≤ = U                 (union with complement = universe)
‚úì A ‚à© A‚Ä≤ = ‚àÖ                 (intersection with complement = empty)
‚úì (A‚Ä≤)‚Ä≤ = A                  (complement of complement)
‚úì A ‚àí B = A ‚à© B‚Ä≤             (difference as intersection)
```

---

## üî¢ 3. TUPLES / SEQUENCES

**Definition:** An ordered list of elements where **order matters**.

**Key Point:** `(a, b) ‚â† (b, a)`

**Example in Automata:** `(q, a)` ‚Üí represents state `q` with input symbol `a`

---

## üî† 4. ALPHABET (Œ£)

**Definition:** A finite set of symbols used to construct strings.

**Examples:**
- `Œ£ = {0, 1}` ‚Üí Binary alphabet
- `Œ£ = {a, b, c}` ‚Üí Simple alphabet
- `Œ£ = {a, b, ..., z}` ‚Üí English lowercase letters

---

## üî§ 5. STRINGS

**Definition:** A finite sequence of symbols from an alphabet Œ£.

### String Notation

| Notation | Meaning | Example |
|----------|---------|---------|
| `w` | A string | `w = 0101` |
| `|w|` | Length of string | `|0101| = 4` |
| `Œµ` | Empty string | `|Œµ| = 0` |
| `xy` | Concatenation | `x=01, y=10 ‚Üí xy=0110` |

### String Operations

**Concatenation:** Joining strings in order
```
x = "01"
y = "10"
xy = "0110"
```

---

## üí• 6. POWERS OF STRINGS

| Notation | Meaning | Example (w = "ab") |
|----------|---------|-------------------|
| `w‚Å∞` | Empty string | `Œµ` |
| `w¬π` | String itself | `ab` |
| `w¬≤` | String repeated twice | `abab` |
| `w¬≥` | String repeated thrice | `ababab` |
| `w‚Åø` | String repeated n times | `w‚Åµ = ababababab` |

---

## üåå 7. KLEENE STAR & PLUS

Used to generate languages from alphabets.

| Symbol | Name | Meaning | Example (Œ£ = {0, 1}) |
|--------|------|---------|----------------------|
| `Œ£*` | Kleene Star | All possible strings (including Œµ) | `{Œµ, 0, 1, 00, 01, 10, 11, 000, ...}` |
| `Œ£‚Å∫` | Kleene Plus | All non-empty strings | `{0, 1, 00, 01, 10, 11, 000, ...}` |

### Key Relationship
```
Œ£* = Œ£‚Å∫ ‚à™ {Œµ}
```

**Example with Œ£ = {a}:**
- `Œ£* = {Œµ, a, aa, aaa, aaaa, ...}`
- `Œ£‚Å∫ = {a, aa, aaa, aaaa, ...}`

---

## üìö 8. LANGUAGES (L)

**Definition:** A set of strings formed using alphabet Œ£.

**Example:**
```
L = {w | w contains at least one '1'}
L = {1, 01, 10, 11, 101, 110, ...}
```

### Language Operations

| Operation | Symbol | Example | Meaning |
|-----------|--------|---------|---------|
| **Union** | `L‚ÇÅ ‚à™ L‚ÇÇ` | `{a,b} ‚à™ {b,c} = {a,b,c}` | Strings in either language |
| **Intersection** | `L‚ÇÅ ‚à© L‚ÇÇ` | `{ab,ba} ‚à© {ab,cd} = {ab}` | Strings in both languages |
| **Concatenation** | `L‚ÇÅL‚ÇÇ` | `{a}{b} = {ab}` | All combinations joined |
| **Kleene Star** | `L*` | `{a}* = {Œµ,a,aa,aaa,...}` | Repeat any number of times |
| **Complement** | `L‚Ä≤` or `LÃÑ` | `Œ£* ‚àí L` | Strings not in L |

### Concatenation Example
```
L‚ÇÅ = {a, ab}
L‚ÇÇ = {c, cd}
L‚ÇÅL‚ÇÇ = {ac, acd, abc, abcd}
```

---

## ‚ö° 9. RELATIONS & FUNCTIONS

### Relations

**Definition:** A connection between elements of two sets.

**Notation:** `R ‚äÜ A √ó B`

**Example:**
```
A = {a, b}
B = {1, 2}
R = {(a,1), (b,2), (b,1)}
```

### Functions

**Definition:** A special relation where each input maps to **exactly one** output.

**Notation:** `f: A ‚Üí B`

**Example:**
```
f(a) = 1
f(b) = 2
```

### Key Rule
```
‚úì Every function is a relation
‚úó Not every relation is a function
```

---

## üß© 10. CARTESIAN PRODUCT

**Definition:** All possible ordered pairs between two sets.

**Notation:** `A √ó B`

**Example:**
```
A = {1, 2}
B = {x, y}

A √ó B = {(1,x), (1,y), (2,x), (2,y)}
```

### Size Formula
```
|A √ó B| = |A| √ó |B|
```

If `|A| = 2` and `|B| = 3`, then `|A √ó B| = 6`

---

## üåÄ 11. POWER SET

**Definition:** The set of all possible subsets of a set.

**Notation:** `P(A)` or `2^A`

**Example:**
```
A = {1, 2}
P(A) = {‚àÖ, {1}, {2}, {1,2}}
```

### Size Formula
```
If |A| = n, then |P(A)| = 2‚Åø
```

**Example:**
- `A = {a, b, c}` where `|A| = 3`
- `|P(A)| = 2¬≥ = 8` subsets

```
P(A) = {
  ‚àÖ, 
  {a}, {b}, {c}, 
  {a,b}, {a,c}, {b,c}, 
  {a,b,c}
}
```

---

## üßÆ 12. LOGICAL OPERATORS

### Basic Operators

| Symbol | Name | Example | Meaning |
|--------|------|---------|---------|
| `¬¨` | NOT | `¬¨p` | Negation of p |
| `‚àß` | AND | `p ‚àß q` | Both must be true |
| `‚à®` | OR | `p ‚à® q` | At least one is true |
| `‚Üí` | IMPLIES | `p ‚Üí q` | If p then q |
| `‚Üî` | IFF | `p ‚Üî q` | If and only if (both ways) |

### Truth Table Quick Reference

| p | q | p‚àßq | p‚à®q | p‚Üíq | p‚Üîq |
|---|---|-----|-----|-----|-----|
| T | T | T   | T   | T   | T   |
| T | F | F   | T   | F   | F   |
| F | T | F   | T   | T   | F   |
| F | F | F   | F   | T   | T   |

### Important Logical Laws

**Commutative Laws:**
```
p ‚à® q = q ‚à® p
p ‚àß q = q ‚àß p
```

**De Morgan's Laws:**
```
¬¨(p ‚à® q) = ¬¨p ‚àß ¬¨q
¬¨(p ‚àß q) = ¬¨p ‚à® ¬¨q
```

**Implication:**
```
p ‚Üí q = ¬¨p ‚à® q
```

**Equivalence (Biconditional):**
```
p ‚Üî q = (p ‚Üí q) ‚àß (q ‚Üí p)
```

**Double Negation:**
```
¬¨(¬¨p) = p
```

---

## üß† 13. QUANTIFIERS

Used in formal logic and proofs.

| Symbol | Name | Example | Meaning |
|--------|------|---------|---------|
| `‚àÄ` | Universal | `‚àÄx (x¬≤ ‚â• 0)` | For all x, x squared is non-negative |
| `‚àÉ` | Existential | `‚àÉx (x = 2)` | There exists an x such that x equals 2 |

### Examples in Context

**Universal Quantifier:**
```
‚àÄx ‚àà N (x ‚â• 0)
"For all x in natural numbers, x is greater than or equal to 0"
```

**Existential Quantifier:**
```
‚àÉx ‚àà R (x¬≤ = 4)
"There exists an x in real numbers such that x squared equals 4"
```

### Negation Rules
```
¬¨(‚àÄx P(x)) = ‚àÉx ¬¨P(x)
¬¨(‚àÉx P(x)) = ‚àÄx ¬¨P(x)
```

---

## ü§ñ 14. USAGE IN AUTOMATA MODELS

### Core Components Across Automata Types

| Notation | Meaning | DFA | NFA | PDA | TM |
|----------|---------|-----|-----|-----|-----|
| **Œ£** | Input Alphabet | ‚úì | ‚úì | ‚úì | ‚úì |
| **Q** | Set of States | ‚úì | ‚úì | ‚úì | ‚úì |
| **Œ¥** | Transition Function | ‚úì | ‚úì | ‚úì | ‚úì |
| **q‚ÇÄ** | Start/Initial State | ‚úì | ‚úì | ‚úì | ‚úì |
| **F** | Final/Accepting States | ‚úì | ‚úì | ‚úì | ‚úì |
| **Œì** | Stack Alphabet | ‚Äî | ‚Äî | ‚úì | ‚Äî |
| **Z‚ÇÄ** | Initial Stack Symbol | ‚Äî | ‚Äî | ‚úì | ‚Äî |
| **B** | Blank Symbol | ‚Äî | ‚Äî | ‚Äî | ‚úì |

### Formal Definitions

**Deterministic Finite Automaton (DFA):**
```
M = (Q, Œ£, Œ¥, q‚ÇÄ, F)
where Œ¥: Q √ó Œ£ ‚Üí Q
```

**Nondeterministic Finite Automaton (NFA):**
```
M = (Q, Œ£, Œ¥, q‚ÇÄ, F)
where Œ¥: Q √ó (Œ£ ‚à™ {Œµ}) ‚Üí P(Q)
```

**Pushdown Automaton (PDA):**
```
M = (Q, Œ£, Œì, Œ¥, q‚ÇÄ, Z‚ÇÄ, F)
where Œ¥: Q √ó (Œ£ ‚à™ {Œµ}) √ó Œì ‚Üí P(Q √ó Œì*)
```

**Turing Machine (TM):**
```
M = (Q, Œ£, Œì, Œ¥, q‚ÇÄ, B, F)
where Œ¥: Q √ó Œì ‚Üí Q √ó Œì √ó {L, R}
```

### Transition Function Examples

**DFA Transition:**
```
Œ¥(q‚ÇÅ, a) = q‚ÇÇ
"From state q‚ÇÅ on input 'a', go to state q‚ÇÇ"
```

**NFA Transition:**
```
Œ¥(q‚ÇÅ, a) = {q‚ÇÇ, q‚ÇÉ}
"From state q‚ÇÅ on input 'a', can go to either q‚ÇÇ or q‚ÇÉ"
```

**PDA Transition:**
```
Œ¥(q‚ÇÅ, a, Z) = {(q‚ÇÇ, ZX)}
"From state q‚ÇÅ, reading 'a', with Z on stack top, go to q‚ÇÇ and push X"
```

**TM Transition:**
```
Œ¥(q‚ÇÅ, a) = (q‚ÇÇ, b, R)
"From state q‚ÇÅ, reading 'a', write 'b', move Right, go to state q‚ÇÇ"
```

---

## üìù Quick Reference Summary

### Most Common Symbols by Category

| Category | Symbols |
|----------|---------|
| **Sets** | `‚àà, ‚àâ, ‚äÜ, ‚äÇ, ‚à™, ‚à©, ‚àí, ‚Ä≤, ‚àÖ` |
| **Strings** | `Œ£, Œµ, *, ‚Å∫, |w|, w‚ÇÅw‚ÇÇ` |
| **Logic** | `¬¨, ‚àß, ‚à®, ‚Üí, ‚Üî, ‚àÄ, ‚àÉ` |
| **Relations** | `√ó, ‚äÜ, ‚Üí, R` |
| **Automata** | `Q, Œ£, Œ¥, q‚ÇÄ, F, Œì` |

### Essential Formulas

**Kleene Operations:**
```
Œ£‚Å∞ = {Œµ}
Œ£‚Åø‚Å∫¬π = {wœÉ | w ‚àà Œ£‚Åø, œÉ ‚àà Œ£}
Œ£* = Œ£‚Å∞ ‚à™ Œ£¬π ‚à™ Œ£¬≤ ‚à™ ...
Œ£‚Å∫ = Œ£¬π ‚à™ Œ£¬≤ ‚à™ Œ£¬≥ ‚à™ ...
```

**Language Closure Properties:**
```
If L‚ÇÅ, L‚ÇÇ are regular, then:
  ‚Ä¢ L‚ÇÅ ‚à™ L‚ÇÇ is regular
  ‚Ä¢ L‚ÇÅ ‚à© L‚ÇÇ is regular
  ‚Ä¢ L‚ÇÅL‚ÇÇ is regular
  ‚Ä¢ L‚ÇÅ* is regular
  ‚Ä¢ LÃÑ‚ÇÅ is regular
```
