# ğŸ§  Theory of Computation â€“ Mathematical Notations

## ğŸ”¤ Basic Concepts

### Alphabet (Î£)
**What it is:** A finite set of symbols/characters used to build strings.  
**Example:** `Î£ = {0, 1}` or `Î£ = {a, b, c}`

### String (w)
**What it is:** A finite sequence of symbols from an alphabet.  
**Example:** `"0110"`, `"abc"`, `"hello"`

### Empty String (Îµ or Î»)
**What it is:** A string with zero characters (length = 0).  
**Notation:** `Îµ` or `Î»`

### String Length (|w|)
**What it is:** The number of symbols in a string.  
**Example:** `|"abc"| = 3`, `|Îµ| = 0`

### Language (L)
**What it is:** A set of strings (can be finite or infinite).  
**Example:** `L = {w | w starts with '0'}` = `{0, 00, 01, 000, 001, ...}`

### Kleene Star (Î£*)
**What it is:** All possible strings (including empty string) that can be formed from alphabet Î£.  
**Example:** `{0,1}* = {Îµ, 0, 1, 00, 01, 10, 11, 000, ...}`

### Kleene Plus (Î£âº)
**What it is:** All possible non-empty strings from alphabet Î£ (excludes Îµ).  
**Example:** `{0,1}âº = {0, 1, 00, 01, 10, 11, 000, ...}`

---

## ğŸ¤– Automata Models

### Finite Automaton (FA)
**What it is:** A simple machine with finite memory that reads input and accepts/rejects strings.  
**Types:** DFA, NFA

### Deterministic Finite Automaton (DFA)
**What it is:** A finite automaton where each state has exactly one transition for each input symbol.  
**Key Rule:** No choices â€” deterministic behavior.  
**Format:** `M = (Q, Î£, Î´, qâ‚€, F)`

### Nondeterministic Finite Automaton (NFA)
**What it is:** A finite automaton where a state can have multiple transitions (or none) for the same input symbol.  
**Key Rule:** Can make choices â€” explores multiple paths simultaneously.  
**Format:** `M = (Q, Î£, Î´, qâ‚€, F)` where `Î´: Q Ã— (Î£ âˆª {Îµ}) â†’ P(Q)`

### Îµ-NFA (Epsilon-NFA)
**What it is:** An NFA that allows transitions without reading any input symbol (Îµ-transitions).  
**Key Feature:** Can "jump" between states for free.

### Pushdown Automaton (PDA)
**What it is:** An automaton with a stack (infinite memory) that can recognize context-free languages.  
**Key Feature:** Can push/pop symbols from stack.  
**Format:** `M = (Q, Î£, Î“, Î´, qâ‚€, Zâ‚€, F)`

### Turing Machine (TM)
**What it is:** The most powerful computational model â€” an automaton with an infinite tape that can read, write, and move left/right.  
**Key Feature:** Can simulate any algorithm.  
**Format:** `M = (Q, Î£, Î“, Î´, qâ‚€, B, F)`

### Linear Bounded Automaton (LBA)
**What it is:** A Turing Machine restricted to use only the tape space occupied by the input.  
**Key Feature:** Limited tape = less power than TM.

---

## ğŸ—ï¸ Automata Components

### State (q)
**What it is:** A configuration/position in the automaton at any moment.  
**Example:** `qâ‚€, qâ‚, qâ‚‚`

### Set of States (Q)
**What it is:** All possible states in the automaton.  
**Example:** `Q = {qâ‚€, qâ‚, qâ‚‚, qâ‚ƒ}`

### Start State (qâ‚€)
**What it is:** The initial state where computation begins.  
**Notation:** `qâ‚€` or marked with an arrow `â†’`

### Final/Accepting State (F)
**What it is:** A state where the automaton accepts the input string.  
**Notation:** Double circle `âŠš` or `F âŠ† Q`

### Transition Function (Î´)
**What it is:** A rule that defines how the automaton moves from one state to another based on input.  
**DFA Example:** `Î´(qâ‚, a) = qâ‚‚`  
**NFA Example:** `Î´(qâ‚, a) = {qâ‚‚, qâ‚ƒ}`

### Dead State (Trap State)
**What it is:** A non-accepting state from which no escape is possible.  
**Purpose:** Captures all rejected strings.

---

## ğŸ“š Language Classes

### Regular Language (Type-3)
**What it is:** A language that can be recognized by a DFA/NFA or described by a regular expression.  
**Examples:** Languages with patterns like "strings ending in '01'", "even number of 0's"

### Context-Free Language (CFL) (Type-2)
**What it is:** A language that can be recognized by a PDA or generated by a context-free grammar.  
**Examples:** Balanced parentheses `{aâ¿bâ¿ | n â‰¥ 0}`, nested structures

### Context-Sensitive Language (CSL) (Type-1)
**What it is:** A language that can be recognized by a Linear Bounded Automaton.  
**Feature:** More complex than CFL but less than recursively enumerable.

### Recursively Enumerable Language (Type-0)
**What it is:** A language that can be recognized by a Turing Machine.  
**Feature:** Most general class â€” may not halt on all inputs.

### Recursive Language
**What it is:** A language that can be decided by a Turing Machine (always halts).  
**Key Difference from RE:** Guaranteed to halt on all inputs.

---

## ğŸ“ Grammars

### Grammar (G)
**What it is:** A set of rules for generating strings in a language.  
**Format:** `G = (V, T, P, S)`

### Context-Free Grammar (CFG)
**What it is:** A grammar where each production rule has a single non-terminal on the left side.  
**Format:** `A â†’ Î±` where `A` is non-terminal, `Î±` is any string of terminals/non-terminals

### Regular Grammar
**What it is:** A restricted CFG where productions are in the form `A â†’ aB` or `A â†’ a`.  
**Types:** Left-linear, Right-linear

### Production Rule (P)
**What it is:** A rule that defines how to replace symbols in a grammar.  
**Example:** `S â†’ aSb | Îµ`

### Terminals (T)
**What it is:** Symbols that appear in the final strings (alphabet symbols).  
**Example:** `{a, b, 0, 1}`

### Non-Terminals (V)
**What it is:** Variables/symbols used to generate strings but don't appear in final output.  
**Example:** `{S, A, B}` (often uppercase letters)

### Start Symbol (S)
**What it is:** The initial non-terminal from which derivation begins.  
**Notation:** Usually `S`

---

## ğŸ¯ Regular Expressions

### Regular Expression (RegEx / RE)
**What it is:** A notation to describe patterns of strings in regular languages.  
**Example:** `(0|1)*` = all binary strings

### Union (|)
**What it is:** Matches either pattern.  
**Example:** `a|b` matches `"a"` or `"b"`

### Concatenation (Â·)
**What it is:** Matches patterns in sequence.  
**Example:** `ab` matches `"ab"`

### Kleene Star (*)
**What it is:** Matches zero or more repetitions.  
**Example:** `a*` matches `"", "a", "aa", "aaa", ...`

### Kleene Plus (+)
**What it is:** Matches one or more repetitions.  
**Example:** `aâº` matches `"a", "aa", "aaa", ...` (not empty string)

---

## ğŸ”„ Closure Properties

### Closure
**What it is:** If you perform an operation on languages of a certain class, the result stays in the same class.  
**Example:** Union of two regular languages is also regular.

### Pumping Lemma
**What it is:** A property used to prove a language is NOT regular or NOT context-free.  
**Idea:** In sufficiently long strings, there's a part you can "pump" (repeat) and stay in the language.

---

## ğŸ§© Decision Problems

### Decidable Problem
**What it is:** A problem for which a Turing Machine can always give a yes/no answer and halt.  
**Example:** "Is this number even?"

### Undecidable Problem
**What it is:** A problem for which no algorithm can solve it for all inputs.  
**Example:** The Halting Problem â€” "Will this program halt on this input?"

### Halting Problem
**What it is:** The problem of determining whether a given program will eventually halt or run forever.  
**Status:** Proven undecidable by Alan Turing.

---

## ğŸ§  Complexity Concepts

### Deterministic Time (P)
**What it is:** Problems solvable by a deterministic Turing Machine in polynomial time.  
**Informal:** "Easy" problems

### Nondeterministic Polynomial Time (NP)
**What it is:** Problems where a solution can be verified in polynomial time.  
**Informal:** "Easy to check" problems

### NP-Complete
**What it is:** The hardest problems in NP â€” if you solve one, you solve them all.  
**Examples:** SAT, Traveling Salesman Problem (decision version)

### NP-Hard
**What it is:** Problems at least as hard as NP-complete problems (may not be in NP).  
**Feature:** No known polynomial-time solution.

---

## ğŸ”§ Special Concepts

### Transition Diagram (State Diagram)
**What it is:** A visual representation of an automaton using circles (states) and arrows (transitions).  
**Purpose:** Easy to understand automaton behavior.

### Acceptance
**What it is:** An automaton accepts a string if, after reading it completely, it ends in a final state.

### Rejection
**What it is:** An automaton rejects a string if it doesn't end in a final state or gets stuck.

### Configuration (Instantaneous Description)
**What it is:** A snapshot of the automaton's current state, remaining input, and stack/tape contents.  
**PDA Example:** `(qâ‚, w, Î±)` â€” state, remaining input, stack

### Derivation
**What it is:** A sequence of steps showing how a string is generated from a grammar's start symbol.  
**Types:** Leftmost, Rightmost

### Parse Tree
**What it is:** A tree representation showing how a string is derived from a grammar.  
**Nodes:** Root = start symbol, leaves = terminals

### Ambiguity
**What it is:** A grammar is ambiguous if a string has more than one parse tree.  
**Problem:** Multiple meanings for the same string.

---

## ğŸ“Š Quick Comparison Table

| Model | Memory | Power | Language Class |
|-------|--------|-------|----------------|
| **DFA** | None (finite states) | Weakest | Regular |
| **NFA** | None (finite states) | Weakest | Regular |
| **PDA** | Stack (infinite) | Medium | Context-Free |
| **LBA** | Limited tape | Strong | Context-Sensitive |
| **TM** | Infinite tape | Strongest | Recursively Enumerable |

---

## ğŸ“ Memory Aid

**Think of it like this:**
- **Alphabet** = Your ingredients
- **String** = A dish made from ingredients
- **Language** = A menu of dishes
- **DFA** = A vending machine (fixed choices)
- **NFA** = A choose-your-own-adventure book (multiple paths)
- **PDA** = A stack of plates (can remember sequence)
- **TM** = A full computer (unlimited power)

## ğŸ“ Greek Symbols

### Most Common in TOC

| Symbol | Name | Usage in TOC |
|--------|------|--------------|
| **`Î£`** | **Sigma** | **Input alphabet (set of symbols)** |
| `Ïƒ` | sigma | A single symbol from alphabet |
| **`Îµ`** | **epsilon** | **Empty string (length 0)** |
| **`Î»`** | **lambda** | **Empty string (alternative) / Lambda calculus** |
| **`Î´`** | **delta** | **Transition function** |
| `Î”` | Delta | Set of transitions |
| `Î“` | Gamma | Stack alphabet (in PDA) |
| `Î³` | gamma | Stack symbol |
| `Ï‰` | omega | String or word |
| `Î©` | Omega | Asymptotic lower bound |
| `Î˜` | Theta | Asymptotic tight bound |
| `Î±` | alpha | Generic variable/symbol |
| `Î²` | beta | Generic variable/symbol |
| `Ï€` | pi | Projection, permutation |
| `Ï` | rho | String, relation |
| `Ï„` | tau | Time, transition |
| `Ï†` / `Ï•` | phi | Function, empty set (alternative) |
| `Ïˆ` | psi | Function, predicate |
| `Î¼` | mu | Minimal element |
| `Î½` | nu | Index variable |

### Complete Greek Alphabet

#### Lowercase Letters

| Symbol | Name | Usage in TOC |
|--------|------|--------------|
| `Î±` | alpha | Variables, strings |
| `Î²` | beta | Variables, strings |
| `Î³` | gamma | Stack symbols |
| `Î´` | delta | Transition function |
| `Îµ` | epsilon | Empty string |
| `Î¶` | zeta | Rarely used |
| `Î·` | eta | Efficiency |
| `Î¸` | theta | Angles, tight bound |
| `Î¹` | iota | Index |
| `Îº` | kappa | Rarely used |
| `Î»` | lambda | Empty string, lambda calculus |
| `Î¼` | mu | Minimal |
| `Î½` | nu | Index |
| `Î¾` | xi | Random variable |
| `Î¿` | omicron | Rarely used |
| `Ï€` | pi | Product, projection |
| `Ï` | rho | Strings |
| `Ïƒ` / `Ï‚` | sigma | Symbol from alphabet |
| `Ï„` | tau | Time |
| `Ï…` | upsilon | Rarely used |
| `Ï†` / `Ï•` | phi | Functions |
| `Ï‡` | chi | Rarely used |
| `Ïˆ` | psi | Functions |
| `Ï‰` | omega | Strings, words |

#### Uppercase Letters

| Symbol | Name | Usage in TOC |
|--------|------|--------------|
| `Î“` | Gamma | Stack alphabet |
| `Î”` | Delta | Transition set, change |
| `Î˜` | Theta | Tight complexity bound |
| `Î›` | Lambda | Set of strings |
| `Î ` | Pi | Product, projection |
| `Î£` | Sigma | Input alphabet |
| `Î¦` | Phi | Functions, sets |
| `Î¨` | Psi | Functions |
| `Î©` | Omega | Lower complexity bound |

### How to Read Common Expressions

#### Automata Definition
```
M = (Q, Î£, Î´, qâ‚€, F)
```
**Read as:** "M equals Q, Sigma, delta, q-zero, F"

#### Transition Function
```
Î´: Q Ã— Î£ â†’ Q
```
**Read as:** "delta from Q cross Sigma to Q"

#### Language
```
L = {Ï‰ | Ï‰ âˆˆ Î£*}
```
**Read as:** "L equals all omega such that omega belongs to Sigma star"

---

## âš™ï¸ 1. SETS

**Definition:** A set is a collection of distinct objects or elements.

**Example:** `A = {1, 2, 3, 4}`

### Set Membership & Relations

| Symbol | Meaning | Example | Explanation |
|--------|---------|---------|-------------|
| `âˆˆ` | belongs to | `2 âˆˆ A` | 2 is an element of A |
| `âˆ‰` | does not belong to | `5 âˆ‰ A` | 5 is not in A |
| `âŠ†` | subset | `{1,2} âŠ† A` | all elements are in A |
| `âŠ‚` | proper subset | `{1,2} âŠ‚ A` | subset but not equal to A |
| `âŠ‡` | superset | `A âŠ‡ {1,2}` | A contains all these elements |
| `|A|` | cardinality | `|A| = 4` | number of elements in A |

---

## ğŸ’¡ 2. SET OPERATIONS

| Operation | Symbol | Example | Result | Meaning |
|-----------|--------|---------|--------|---------|
| **Union** | `âˆª` | `{1,2} âˆª {2,3}` | `{1,2,3}` | Combine both sets |
| **Intersection** | `âˆ©` | `{1,2} âˆ© {2,3}` | `{2}` | Common elements only |
| **Difference** | `âˆ’` | `{1,2,3} âˆ’ {2}` | `{1,3}` | Elements only in first set |
| **Complement** | `Aâ€²` or `Ä€` | `U={1,2,3,4}, A={1,2}` | `Aâ€²={3,4}` | Elements not in A |

### Important Set Rules

```
âœ“ A âˆª âˆ… = A                  (union with empty set)
âœ“ A âˆ© âˆ… = âˆ…                  (intersection with empty set)
âœ“ A âˆª Aâ€² = U                 (union with complement = universe)
âœ“ A âˆ© Aâ€² = âˆ…                 (intersection with complement = empty)
âœ“ (Aâ€²)â€² = A                  (complement of complement)
âœ“ A âˆ’ B = A âˆ© Bâ€²             (difference as intersection)
```

---

## ğŸ”¢ 3. TUPLES / SEQUENCES

**Definition:** An ordered list of elements where **order matters**.

**Key Point:** `(a, b) â‰  (b, a)`

**Example in Automata:** `(q, a)` â†’ represents state `q` with input symbol `a`

---

## ğŸ”  4. ALPHABET (Î£)

**Definition:** A finite set of symbols used to construct strings.

**Examples:**
- `Î£ = {0, 1}` â†’ Binary alphabet
- `Î£ = {a, b, c}` â†’ Simple alphabet
- `Î£ = {a, b, ..., z}` â†’ English lowercase letters

---

## ğŸ”¤ 5. STRINGS

**Definition:** A finite sequence of symbols from an alphabet Î£.

### String Notation

| Notation | Meaning | Example |
|----------|---------|---------|
| `w` | A string | `w = 0101` |
| `|w|` | Length of string | `|0101| = 4` |
| `Îµ` | Empty string | `|Îµ| = 0` |
| `xy` | Concatenation | `x=01, y=10 â†’ xy=0110` |

### String Operations

**Concatenation:** Joining strings in order
```
x = "01"
y = "10"
xy = "0110"
```

---

## ğŸ’¥ 6. POWERS OF STRINGS

| Notation | Meaning | Example (w = "ab") |
|----------|---------|-------------------|
| `wâ°` | Empty string | `Îµ` |
| `wÂ¹` | String itself | `ab` |
| `wÂ²` | String repeated twice | `abab` |
| `wÂ³` | String repeated thrice | `ababab` |
| `wâ¿` | String repeated n times | `wâµ = ababababab` |

---

## ğŸŒŒ 7. KLEENE STAR & PLUS

Used to generate languages from alphabets.

| Symbol | Name | Meaning | Example (Î£ = {0, 1}) |
|--------|------|---------|----------------------|
| `Î£*` | Kleene Star | All possible strings (including Îµ) | `{Îµ, 0, 1, 00, 01, 10, 11, 000, ...}` |
| `Î£âº` | Kleene Plus | All non-empty strings | `{0, 1, 00, 01, 10, 11, 000, ...}` |

### Key Relationship
```
Î£* = Î£âº âˆª {Îµ}
```

**Example with Î£ = {a}:**
- `Î£* = {Îµ, a, aa, aaa, aaaa, ...}`
- `Î£âº = {a, aa, aaa, aaaa, ...}`

---

## ğŸ“š 8. LANGUAGES (L)

**Definition:** A set of strings formed using alphabet Î£.

**Example:**
```
L = {w | w contains at least one '1'}
L = {1, 01, 10, 11, 101, 110, ...}
```

### Language Operations

| Operation | Symbol | Example | Meaning |
|-----------|--------|---------|---------|
| **Union** | `Lâ‚ âˆª Lâ‚‚` | `{a,b} âˆª {b,c} = {a,b,c}` | Strings in either language |
| **Intersection** | `Lâ‚ âˆ© Lâ‚‚` | `{ab,ba} âˆ© {ab,cd} = {ab}` | Strings in both languages |
| **Concatenation** | `Lâ‚Lâ‚‚` | `{a}{b} = {ab}` | All combinations joined |
| **Kleene Star** | `L*` | `{a}* = {Îµ,a,aa,aaa,...}` | Repeat any number of times |
| **Complement** | `Lâ€²` or `LÌ„` | `Î£* âˆ’ L` | Strings not in L |

### Concatenation Example
```
Lâ‚ = {a, ab}
Lâ‚‚ = {c, cd}
Lâ‚Lâ‚‚ = {ac, acd, abc, abcd}
```

---

## âš¡ 9. RELATIONS & FUNCTIONS

### Relations

**Definition:** A connection between elements of two sets.

**Notation:** `R âŠ† A Ã— B`

**Example:**
```
A = {a, b}
B = {1, 2}
R = {(a,1), (b,2), (b,1)}
```

### Functions

**Definition:** A special relation where each input maps to **exactly one** output.

**Notation:** `f: A â†’ B`

**Example:**
```
f(a) = 1
f(b) = 2
```

### Key Rule
```
âœ“ Every function is a relation
âœ— Not every relation is a function
```

---

## ğŸ§© 10. CARTESIAN PRODUCT

**Definition:** All possible ordered pairs between two sets.

**Notation:** `A Ã— B`

**Example:**
```
A = {1, 2}
B = {x, y}

A Ã— B = {(1,x), (1,y), (2,x), (2,y)}
```

### Size Formula
```
|A Ã— B| = |A| Ã— |B|
```

If `|A| = 2` and `|B| = 3`, then `|A Ã— B| = 6`

---

## ğŸŒ€ 11. POWER SET

**Definition:** The set of all possible subsets of a set.

**Notation:** `P(A)` or `2^A`

**Example:**
```
A = {1, 2}
P(A) = {âˆ…, {1}, {2}, {1,2}}
```

### Size Formula
```
If |A| = n, then |P(A)| = 2â¿
```

**Example:**
- `A = {a, b, c}` where `|A| = 3`
- `|P(A)| = 2Â³ = 8` subsets

```
P(A) = {
  âˆ…, 
  {a}, {b}, {c}, 
  {a,b}, {a,c}, {b,c}, 
  {a,b,c}
}
```

---

## ğŸ§® 12. LOGICAL OPERATORS

### Basic Operators

| Symbol | Name | Example | Meaning |
|--------|------|---------|---------|
| `Â¬` | NOT | `Â¬p` | Negation of p |
| `âˆ§` | AND | `p âˆ§ q` | Both must be true |
| `âˆ¨` | OR | `p âˆ¨ q` | At least one is true |
| `â†’` | IMPLIES | `p â†’ q` | If p then q |
| `â†”` | IFF | `p â†” q` | If and only if (both ways) |

### Truth Table Quick Reference

| p | q | pâˆ§q | pâˆ¨q | pâ†’q | pâ†”q |
|---|---|-----|-----|-----|-----|
| T | T | T   | T   | T   | T   |
| T | F | F   | T   | F   | F   |
| F | T | F   | T   | T   | F   |
| F | F | F   | F   | T   | T   |

### Important Logical Laws

**Commutative Laws:**
```
p âˆ¨ q = q âˆ¨ p
p âˆ§ q = q âˆ§ p
```

**De Morgan's Laws:**
```
Â¬(p âˆ¨ q) = Â¬p âˆ§ Â¬q
Â¬(p âˆ§ q) = Â¬p âˆ¨ Â¬q
```

**Implication:**
```
p â†’ q = Â¬p âˆ¨ q
```

**Equivalence (Biconditional):**
```
p â†” q = (p â†’ q) âˆ§ (q â†’ p)
```

**Double Negation:**
```
Â¬(Â¬p) = p
```

---

## ğŸ§  13. QUANTIFIERS

Used in formal logic and proofs.

| Symbol | Name | Example | Meaning |
|--------|------|---------|---------|
| `âˆ€` | Universal | `âˆ€x (xÂ² â‰¥ 0)` | For all x, x squared is non-negative |
| `âˆƒ` | Existential | `âˆƒx (x = 2)` | There exists an x such that x equals 2 |

### Examples in Context

**Universal Quantifier:**
```
âˆ€x âˆˆ N (x â‰¥ 0)
"For all x in natural numbers, x is greater than or equal to 0"
```

**Existential Quantifier:**
```
âˆƒx âˆˆ R (xÂ² = 4)
"There exists an x in real numbers such that x squared equals 4"
```

### Negation Rules
```
Â¬(âˆ€x P(x)) = âˆƒx Â¬P(x)
Â¬(âˆƒx P(x)) = âˆ€x Â¬P(x)
```

---

## ğŸ¤– 14. USAGE IN AUTOMATA MODELS

### Core Components Across Automata Types

| Notation | Meaning | DFA | NFA | PDA | TM |
|----------|---------|-----|-----|-----|-----|
| **Î£** | Input Alphabet | âœ“ | âœ“ | âœ“ | âœ“ |
| **Q** | Set of States | âœ“ | âœ“ | âœ“ | âœ“ |
| **Î´** | Transition Function | âœ“ | âœ“ | âœ“ | âœ“ |
| **qâ‚€** | Start/Initial State | âœ“ | âœ“ | âœ“ | âœ“ |
| **F** | Final/Accepting States | âœ“ | âœ“ | âœ“ | âœ“ |
| **Î“** | Stack Alphabet | â€” | â€” | âœ“ | â€” |
| **Zâ‚€** | Initial Stack Symbol | â€” | â€” | âœ“ | â€” |
| **B** | Blank Symbol | â€” | â€” | â€” | âœ“ |

### Formal Definitions

**Deterministic Finite Automaton (DFA):**
```
M = (Q, Î£, Î´, qâ‚€, F)
where Î´: Q Ã— Î£ â†’ Q
```

**Nondeterministic Finite Automaton (NFA):**
```
M = (Q, Î£, Î´, qâ‚€, F)
where Î´: Q Ã— (Î£ âˆª {Îµ}) â†’ P(Q)
```

**Pushdown Automaton (PDA):**
```
M = (Q, Î£, Î“, Î´, qâ‚€, Zâ‚€, F)
where Î´: Q Ã— (Î£ âˆª {Îµ}) Ã— Î“ â†’ P(Q Ã— Î“*)
```

**Turing Machine (TM):**
```
M = (Q, Î£, Î“, Î´, qâ‚€, B, F)
where Î´: Q Ã— Î“ â†’ Q Ã— Î“ Ã— {L, R}
```

### Transition Function Examples

**DFA Transition:**
```
Î´(qâ‚, a) = qâ‚‚
"From state qâ‚ on input 'a', go to state qâ‚‚"
```

**NFA Transition:**
```
Î´(qâ‚, a) = {qâ‚‚, qâ‚ƒ}
"From state qâ‚ on input 'a', can go to either qâ‚‚ or qâ‚ƒ"
```

**PDA Transition:**
```
Î´(qâ‚, a, Z) = {(qâ‚‚, ZX)}
"From state qâ‚, reading 'a', with Z on stack top, go to qâ‚‚ and push X"
```

**TM Transition:**
```
Î´(qâ‚, a) = (qâ‚‚, b, R)
"From state qâ‚, reading 'a', write 'b', move Right, go to state qâ‚‚"
```

---

## ğŸ“ Quick Reference Summary

### Most Common Symbols by Category

| Category | Symbols |
|----------|---------|
| **Sets** | `âˆˆ, âˆ‰, âŠ†, âŠ‚, âˆª, âˆ©, âˆ’, â€², âˆ…` |
| **Strings** | `Î£, Îµ, *, âº, |w|, wâ‚wâ‚‚` |
| **Logic** | `Â¬, âˆ§, âˆ¨, â†’, â†”, âˆ€, âˆƒ` |
| **Relations** | `Ã—, âŠ†, â†’, R` |
| **Automata** | `Q, Î£, Î´, qâ‚€, F, Î“` |

### Essential Formulas

**Kleene Operations:**
```
Î£â° = {Îµ}
Î£â¿âºÂ¹ = {wÏƒ | w âˆˆ Î£â¿, Ïƒ âˆˆ Î£}
Î£* = Î£â° âˆª Î£Â¹ âˆª Î£Â² âˆª ...
Î£âº = Î£Â¹ âˆª Î£Â² âˆª Î£Â³ âˆª ...
```

**Language Closure Properties:**
```
If Lâ‚, Lâ‚‚ are regular, then:
  â€¢ Lâ‚ âˆª Lâ‚‚ is regular
  â€¢ Lâ‚ âˆ© Lâ‚‚ is regular
  â€¢ Lâ‚Lâ‚‚ is regular
  â€¢ Lâ‚* is regular
  â€¢ LÌ„â‚ is regular
```
